{
        externalLayers: {
            bingLayer: {
                label: 'Bing Layer',
                key: 'AuhiCJHlGzhg93IqUH_oCpl_-ZUrIE6SPftlyGYUvr9Amx5nzA-WqGcPquyFZl4L',
            }
        },
        withUrl: {
            mapbox: {
                label: 'MapBox',
                mapOpts: {
                    url: 'https://api.mapbox.com/v4/mapbox.streets/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoicmFrc2hhayIsImEiOiJ5cHhqeHlRIn0.Vi87VjI1cKbl1lhOn95Lpw',
                    options: {
                        attribution: '© <a href="https://www.mapbox.com/feedback/">Mapbox</a> © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    }
                }
            },
            googleSatLayer: {
                label: 'Google Satellite',
                mapOpts: {
                    url: 'http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
                    options: {
                        maxZoom: 20,
                        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
                    }
                }

            }
        }
    }










             /*   $('body').off('click', this.options.submitBtnSelector);

            $('body').on('click', this.options.submitBtnSelector, function (e) {
                e.preventDefault();
                var formData = parseAttributesForm(self.formDomObj);

                if (self.options.updateCb && self.options.updateCb instanceof Function) {
                    self.options.updateCb(formData, self)
                }
            });*/















    /**
     * Create leaflet Markers from  marker definitions - markersData
     *
     * @param markersData       - marker definitions {lat:, lng: , draggable: .... other}
     * @param leafletMap        - leaflet map instance
     * @param layerGroup        - if specified markers will be added to this layer group L.layerGroup([])
     * @param addToMap boolean  - if true will add marker layer to leaflet map
     * @param clearLayer boolean - if true will clear provided layer
     * @returns {layerGroup} featureMarkers
     */
    function _createMarkersOnLayer(options) {
        var markersData = options.markersData;
        var addToMap = options.addToMap;
        var clearLayer = options.clearLayer;
        var iconIdentifierKey = options.iconIdentifierKey;

        _handleLayers(clearLayer, addToMap);

        var i = 0, marker;

        var dataCnt = markersData.length;

        for (i; i < dataCnt; i += 1) {
            marker = createDashBoardMarker({
                marker: markersData[i],
                iconIdentifierKey: iconIdentifierKey
            });
            marker.addTo(featureMarkers);

        }

        return featureMarkers;
    }



.wb-actions-row {
    width: 100%;
    display: block;
    position: relative;
    padding: 0.1em 0 0.3em;
}


.wb-actions-row .wb-actions {
    padding: 0 5px;
}

.wb-actions-row .geo-search-wrap {
    position: relative;
    display: block;
    float: right;
    width: 100%;
    min-width: 150px;
    max-width: 350px;
}












<div class="navbar navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#wb-navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/" title="Waterboard"></a>
        </div>
        <div class="collapse navbar-collapse" id="wb-navbar-collapse">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a href="/table-report">Back <span class="sr-only">(current)</span></a>
                </li>
{#                <li><a href="#">Link</a></li>#}
            </ul>
            <ul class="nav navbar-nav navbar-right">
                {% if not user.is_authenticated %}
                    <li id="login_id">
                        <a href="/login">

                            Login
                        </a>
                    </li>
                {% else %}
                    <li>
                        <a href="/logout">
                            Logout
                        </a>
                    </li>
                {% endif %}
            </ul>
        </div>
    </div>
</div>
</nav>





/**
 * Get chart filter keys (filter field names) from chart config
 * @param chartConf
 * @returns {*}
 */
DashboardController.getFilterableChartKeys = function (chartConf) {
    return Object.keys(chartConf).reduce(function (acc, val, i) {
        if (chartConf[val].isFilter === true) {
            acc[acc.length] = chartConf[val].name;
        }
        return acc;
    }, []);
};






/**
 * Get chart keys for specified chart type
 * @param chartConf
 * @param chartType
 * @returns {*}
 */
DashboardController.getChartKeysByChartType = function (chartConf, chartType) {
    return Object.keys(chartConf).reduce(function (acc, val, i) {
        if (chartConf[val].chartType === chartType) {
            acc[acc.length] = val;
        }
        return acc;
    }, []);
};










function SimpleStorage(storage) {
    this.storage = storage || {};
}


// TODO unneded - remoev prolly
SimpleStorage.prototype = {
    setItem: function (key, val) {
        this.storage[key] = val;
        return this.storage[key];
    },
    getItem: function (key) {
        if (key !== undefined && key !== null) {
            return _.get(this.storage, key);
        }
        return this.storage;
    },
    getItems: function (keys) {
        var key, i = 0, items = {};

        var keysCnt = (keys || []).length;

        if (keysCnt > 1) {
            for (i; i < keysCnt; i += i) {
                key = keys[i];

                if (key !== undefined && key !== null) {
                    items[key] = _.get(this.storage, key);
                }
            }
            return items;
        }
        return this.storage;
    },

    removeItem: function (key) {
        delete this.storage[key];
    },
    setStorage: function (storage) {
        this.storage = storage || {};
    }
};

WB.Storage = new SimpleStorage(globalVars);


















    /** TODO REMOVE
     * After resize / debounce
     * @param func
     * @param wait
     * @param endCheck
     * @returns {Function}
     */
    function _debounce(func, wait, endCheck) {
        var timeout;

        return function () {
            const that = this;
            const args = arguments;

            const later = function () {
                timeout = null;
                if (!endCheck) {
                    func.apply(that, args);
                }
            };

            const callNow = endCheck && !timeout;

            clearTimeout(timeout);

            timeout = setTimeout(later, wait);

            if (callNow) {
                func.apply(that, args);
            }
        };
    }











    /** TODO remove
     * taken  from: https://github.com/cosmosio/nested-property
     * Get the property of an object nested in one or more objects
     * given an object such as a.b.c.d = 5, getNestedProperty(a, "b.c.d") will return 5.
     * @param {Object} object the object to get the property from
     * @param {String} property the path to the property as a string
     * @returns the object or the the property value if found
     */
    function _getNestedProperty(object, property) {
        if (object && typeof object == "object") {
            if (typeof property == "string" && property !== "") {
                var split = property.split(".");
                return split.reduce(function (obj, prop) {
                    return obj && obj[prop];
                }, object);
            } else if (typeof property == "number") {
                return object[property];
            } else {
                return object;
            }
        } else {
            return object;
        }
    }
